import sqlite3 from 'sqlite3';
import bcrypt from 'bcrypt';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class Database {
  constructor() {
    this.db = null;
    this.dbPath = path.join(__dirname, '..', 'data', 'musicstream.db');
  }

  async init() {
    return new Promise((resolve, reject) => {
      // Ensure data directory exists
      const dataDir = path.dirname(this.dbPath);
      if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
      }

      this.db = new sqlite3.Database(this.dbPath, (err) => {
        if (err) {
          console.error('Database connection error:', err);
          reject(err);
        } else {
          console.log('âœ… Database connected:', this.dbPath);
          this.createTables().then(resolve).catch(reject);
        }
      });
    });
  }

  async createTables() {
    return new Promise((resolve, reject) => {
      const queries = [
        // Users table
        `CREATE TABLE IF NOT EXISTS users (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          username TEXT UNIQUE NOT NULL,
          email TEXT,
          password_hash TEXT NOT NULL,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          last_login DATETIME,
          is_active BOOLEAN DEFAULT 1
        )`,

        // Music library table (centralized - like Spotify)
        `CREATE TABLE IF NOT EXISTS music_library (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          file_path TEXT UNIQUE NOT NULL,
          title TEXT,
          artist TEXT,
          album TEXT,
          year INTEGER,
          genre TEXT,
          duration INTEGER,
          file_size INTEGER,
          bitrate INTEGER,
          added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          last_played DATETIME,
          play_count INTEGER DEFAULT 0
        )`,
        
        // User library table (which tracks each user has added)
        `CREATE TABLE IF NOT EXISTS user_library (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER NOT NULL,
          music_id INTEGER NOT NULL,
          added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          UNIQUE(user_id, music_id),
          FOREIGN KEY (user_id) REFERENCES users (id),
          FOREIGN KEY (music_id) REFERENCES music_library (id)
        )`,


        // Playlists table
        `CREATE TABLE IF NOT EXISTS playlists (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          user_id INTEGER,
          name TEXT NOT NULL,
          description TEXT,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (user_id) REFERENCES users (id)
        )`,

        // Playlist tracks table
        `CREATE TABLE IF NOT EXISTS playlist_tracks (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          playlist_id INTEGER,
          music_id INTEGER,
          position INTEGER,
          added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          FOREIGN KEY (playlist_id) REFERENCES playlists (id),
          FOREIGN KEY (music_id) REFERENCES music_library (id)
        )`,

        // Downloads table
        `CREATE TABLE IF NOT EXISTS downloads (
          id TEXT PRIMARY KEY,
          user_id INTEGER,
          playlist_id INTEGER,
          title TEXT NOT NULL,
          artist TEXT NOT NULL,
          album TEXT,
          status TEXT DEFAULT 'downloading',
          progress INTEGER DEFAULT 0,
          created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
          torrent_data TEXT,
          retry_count INTEGER DEFAULT 0,
          last_retry DATETIME,
          error_log TEXT,
          FOREIGN KEY (user_id) REFERENCES users (id),
          FOREIGN KEY (playlist_id) REFERENCES playlists (id)
        )`
      ];

      let completed = 0;
      queries.forEach((query, index) => {
        this.db.run(query, (err) => {
          if (err) {
            console.error(`Error creating table ${index + 1}:`, err);
            reject(err);
          } else {
            completed++;
            if (completed === queries.length) {
              console.log('âœ… Database tables created');
              // Add missing columns if they don't exist
              this.addMissingColumns().then(() => resolve()).catch(reject);
            }
          }
        });
      });
    });
  }

  // Add missing columns to existing tables
  async addMissingColumns() {
    return new Promise((resolve, reject) => {
      const migrations = [
        'ALTER TABLE music_library ADD COLUMN user_id INTEGER',
        'ALTER TABLE music_library ADD COLUMN album_cover TEXT',
        'ALTER TABLE music_library ADD COLUMN artist_image TEXT',
        'ALTER TABLE downloads ADD COLUMN retry_count INTEGER DEFAULT 0',
        'ALTER TABLE downloads ADD COLUMN last_retry DATETIME',
        'ALTER TABLE downloads ADD COLUMN error_log TEXT',
        'ALTER TABLE downloads ADD COLUMN user_id INTEGER',
        'ALTER TABLE downloads ADD COLUMN playlist_id INTEGER',
        'ALTER TABLE users ADD COLUMN theme_preference TEXT DEFAULT "apple-glass-black"',
        'ALTER TABLE users ADD COLUMN is_admin BOOLEAN DEFAULT 0'
      ];

      let completed = 0;
      migrations.forEach((migration, index) => {
        this.db.run(migration, (err) => {
          if (err && !err.message.includes('duplicate column name')) {
            console.warn(`Migration ${index + 1} failed:`, err.message);
          } else if (!err) {
            console.log(`âœ… Migration ${index + 1} applied`);
          }
          
          completed++;
          if (completed === migrations.length) {
            console.log('âœ… Database migrations completed');
            // Add indexes after migrations complete
            this.createIndexes().then(() => resolve()).catch(reject);
          }
        });
      });
    });
  }

  // Create indexes for performance
  async createIndexes() {
    return new Promise((resolve, reject) => {
      const indexes = [
        // Music library indexes
        'CREATE INDEX IF NOT EXISTS idx_music_library_user_id ON music_library(user_id)',
        'CREATE INDEX IF NOT EXISTS idx_music_library_artist ON music_library(artist)',
        'CREATE INDEX IF NOT EXISTS idx_music_library_album ON music_library(album)',
        'CREATE INDEX IF NOT EXISTS idx_music_library_title ON music_library(title)',
        'CREATE INDEX IF NOT EXISTS idx_music_library_added_at ON music_library(added_at)',
        
        // User library indexes
        'CREATE INDEX IF NOT EXISTS idx_user_library_user_id ON user_library(user_id)',
        'CREATE INDEX IF NOT EXISTS idx_user_library_music_id ON user_library(music_id)',
        'CREATE INDEX IF NOT EXISTS idx_user_library_composite ON user_library(user_id, music_id)',
        
        // Playlist indexes
        'CREATE INDEX IF NOT EXISTS idx_playlists_user_id ON playlists(user_id)',
        
        // Playlist tracks indexes
        'CREATE INDEX IF NOT EXISTS idx_playlist_tracks_playlist_id ON playlist_tracks(playlist_id)',
        'CREATE INDEX IF NOT EXISTS idx_playlist_tracks_music_id ON playlist_tracks(music_id)',
        'CREATE INDEX IF NOT EXISTS idx_playlist_tracks_position ON playlist_tracks(playlist_id, position)',
        
        // Downloads indexes
        'CREATE INDEX IF NOT EXISTS idx_downloads_user_id ON downloads(user_id)',
        'CREATE INDEX IF NOT EXISTS idx_downloads_status ON downloads(status)',
        'CREATE INDEX IF NOT EXISTS idx_downloads_playlist_id ON downloads(playlist_id)'
      ];

      let completed = 0;
      indexes.forEach((indexQuery, index) => {
        this.db.run(indexQuery, (err) => {
          if (err) {
            console.warn(`âš ï¸ Index ${index + 1} failed:`, err.message);
          } else {
            console.log(`âœ… Index ${index + 1} created`);
          }
          
          completed++;
          if (completed === indexes.length) {
            console.log('âœ… Database indexes verified');
            resolve();
          }
        });
      });
    });
  }

  // User methods
  async createUser(username, password) {
    const hashedPassword = await bcrypt.hash(password, 10);
    
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)',
        [username, '', hashedPassword],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve({ id: this.lastID, username, email: '' });
          }
        }
      );
    });
  }

  async getUserByUsername(username) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM users WHERE username = ? AND is_active = 1',
        [username],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }

  async getUserByEmail(email) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM users WHERE email = ? AND is_active = 1',
        [email],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }

  async getUserById(id) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM users WHERE id = ? AND is_active = 1',
        [id],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }

  async validatePassword(username, password) {
    const user = await this.getUserByUsername(username);
    if (!user) return null;
    
    const isValid = await bcrypt.compare(password, user.password_hash);
    return isValid ? user : null;
  }

  async updateLastLogin(userId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?',
        [userId],
        (err) => {
          if (err) reject(err);
          else resolve();
        }
      );
    });
  }

  // Music library methods (with user ownership)
  async addMusicToLibrary(filePath, metadata, userId = null) {
    const self = this;
    return new Promise((resolve, reject) => {
      // Add to music_library with user_id (or ignore if exists)
      self.db.run(
        `INSERT OR IGNORE INTO music_library 
         (file_path, title, artist, album, year, genre, duration, file_size, bitrate, album_cover, artist_image, user_id)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          filePath,
          metadata.title,
          metadata.artist,
          metadata.album,
          metadata.year,
          metadata.genre,
          metadata.duration,
          metadata.fileSize,
          metadata.bitrate,
          metadata.album_cover || null,
          metadata.artist_image || null,
          userId // Add user_id to the insert
        ],
        function(err) {
          if (err) {
            reject(err);
            return;
          }
          
          // Get the music_id (either just inserted or existing)
          self.db.get(
            'SELECT id FROM music_library WHERE file_path = ?',
            [filePath],
            (err, row) => {
              if (err) {
                reject(err);
                return;
              }
              
              if (!row) {
                reject(new Error('Music not found after insert'));
                return;
              }
              
              const musicId = row.id;
              
              // If artwork was provided and this is an existing track, update it
              if ((metadata.album_cover || metadata.artist_image)) {
                self.updateMusicArtwork(musicId, metadata.album_cover, metadata.artist_image)
                  .catch(err => console.warn('Could not update artwork:', err));
              }
              
              // If userId provided, add to their library
              if (userId) {
                self.addToUserLibrary(userId, musicId).then(() => {
                  resolve({ id: musicId });
                }).catch(reject);
              } else {
                resolve({ id: musicId });
              }
            }
          );
        }
      );
    });
  }

  // Check if user is admin
  async isUserAdmin(userId) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT is_admin FROM users WHERE id = ?',
        [userId],
        (err, row) => {
          if (err) reject(err);
          else resolve(row && row.is_admin === 1);
        }
      );
    });
  }

  async getMusicLibrary(limit = null, offset = 0, userId = null) {
    return new Promise(async (resolve, reject) => {
      try {
        let query, params;
        
        // Check if user is admin
        const isAdmin = userId ? await this.isUserAdmin(userId) : false;
        
        if (userId && !isAdmin) {
          // Regular user: Show only their music (user_id matches OR user_id is NULL for global music)
          if (limit) {
            query = `
              SELECT * FROM music_library 
              WHERE user_id = ? OR user_id IS NULL
              ORDER BY added_at DESC
              LIMIT ? OFFSET ?
            `;
            params = [userId, limit, offset];
          } else {
            query = `
              SELECT * FROM music_library 
              WHERE user_id = ? OR user_id IS NULL
              ORDER BY added_at DESC
            `;
            params = [userId];
          }
        } else {
          // Admin or no userId: Show ALL music
          if (limit) {
            query = `SELECT * FROM music_library ORDER BY added_at DESC LIMIT ? OFFSET ?`;
            params = [limit, offset];
          } else {
            query = `SELECT * FROM music_library ORDER BY added_at DESC`;
            params = [];
          }
        }
        
        this.db.all(query, params, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  
  // Add track to user's library (Spotify-like)
  async addToUserLibrary(userId, musicId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT OR IGNORE INTO user_library (user_id, music_id) VALUES (?, ?)`,
        [userId, musicId],
        function(err) {
          if (err) reject(err);
          else resolve({ success: true, id: this.lastID });
        }
      );
    });
  }
  
  // Remove track from user's library
  async removeFromUserLibrary(userId, musicId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `DELETE FROM user_library WHERE user_id = ? AND music_id = ?`,
        [userId, musicId],
        function(err) {
          if (err) reject(err);
          else resolve({ success: true });
        }
      );
    });
  }
  
  // Update artwork URLs for music
  async updateMusicArtwork(musicId, albumCover = null, artistImage = null) {
    return new Promise((resolve, reject) => {
      const updates = [];
      const params = [];
      
      if (albumCover !== null) {
        updates.push('album_cover = ?');
        params.push(albumCover);
      }
      
      if (artistImage !== null) {
        updates.push('artist_image = ?');
        params.push(artistImage);
      }
      
      if (updates.length === 0) {
        resolve({ success: true });
        return;
      }
      
      params.push(musicId);
      const query = `UPDATE music_library SET ${updates.join(', ')} WHERE id = ?`;
      
      this.db.run(query, params, function(err) {
        if (err) reject(err);
        else resolve({ success: true, changes: this.changes });
      });
    });
  }

  async getMusicById(id) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM music_library WHERE id = ?',
        [id],
        (err, row) => {
          if (err) reject(err);
          else resolve(row);
        }
      );
    });
  }
  
  // Find existing music by artist and title (for duplicate check)
  async findMusicByArtistAndTitle(artist, title) {
    return new Promise((resolve, reject) => {
      // Try exact match first
      this.db.get(
        `SELECT * FROM music_library 
         WHERE LOWER(TRIM(artist)) = LOWER(TRIM(?)) AND LOWER(TRIM(title)) = LOWER(TRIM(?)) 
         LIMIT 1`,
        [artist, title],
        (err, exactMatch) => {
          if (err) {
            reject(err);
            return;
          }
          
          if (exactMatch) {
            resolve(exactMatch);
            return;
          }
          
          // Try fuzzy match - check if title contains or artist contains
          this.db.get(
            `SELECT * FROM music_library 
             WHERE LOWER(TRIM(artist)) LIKE LOWER(TRIM(?)) 
             AND LOWER(TRIM(title)) LIKE LOWER(TRIM(?))
             LIMIT 1`,
            [`%${artist}%`, `%${title}%`],
            (err2, fuzzyMatch) => {
              if (err2) reject(err2);
              else resolve(fuzzyMatch || null);
            }
          );
        }
      );
    });
  }

  async searchMusic(query) {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT * FROM music_library 
         WHERE title LIKE ? OR artist LIKE ? OR album LIKE ?
         ORDER BY play_count DESC, added_at DESC`,
        [`%${query}%`, `%${query}%`, `%${query}%`],
        (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        }
      );
    });
  }

  // Download methods
  async addDownload(userId, title, artist, album, magnetUrl) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT INTO downloads (user_id, title, artist, album, magnet_url)
         VALUES (?, ?, ?, ?, ?)`,
        [userId, title, artist, album, magnetUrl],
        function(err) {
          if (err) reject(err);
          else resolve({ id: this.lastID });
        }
      );
    });
  }

  async getDownloads(userId = null) {
    return new Promise((resolve, reject) => {
      let query = 'SELECT * FROM downloads';
      let params = [];
      
      if (userId) {
        query += ' WHERE user_id = ?';
        params.push(userId);
      }
      
      query += ' ORDER BY created_at DESC';
      
      this.db.all(query, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }

  async updateDownloadStatus(downloadId, status, progress = null, filePath = null) {
    return new Promise((resolve, reject) => {
      let query = 'UPDATE downloads SET status = ?';
      let params = [status];
      
      if (progress !== null) {
        query += ', progress = ?';
        params.push(progress);
      }
      
      if (filePath) {
        query += ', file_path = ?';
        params.push(filePath);
      }
      
      if (status === 'completed') {
        query += ', completed_at = CURRENT_TIMESTAMP';
      }
      
      query += ' WHERE id = ?';
      params.push(downloadId);
      
      this.db.run(query, params, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  async   close() {
    return new Promise((resolve) => {
      if (this.db) {
        this.db.close((err) => {
          if (err) console.error('Error closing database:', err);
          else console.log('Database connection closed');
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  // Admin methods
  async getAllUsers() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT id, username, email, created_at, last_login, is_active FROM users ORDER BY created_at DESC',
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async getMusicStats() {
    return new Promise((resolve, reject) => {
      this.db.get(
        `SELECT 
          COUNT(*) as total_songs,
          SUM(play_count) as total_plays,
          AVG(play_count) as avg_plays,
          COUNT(DISTINCT artist) as unique_artists,
          COUNT(DISTINCT album) as unique_albums,
          SUM(file_size) as total_size_bytes
        FROM music_library`,
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        }
      );
    });
  }

  async getMostPlayedSongs(limit = 10) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM music_library ORDER BY play_count DESC LIMIT ?',
        [limit],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async getMusicWithPagination(limit, offset) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM music_library ORDER BY added_at DESC LIMIT ? OFFSET ?',
        [limit, offset],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async getMusicCount() {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT COUNT(*) as count FROM music_library',
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row.count);
          }
        }
      );
    });
  }

  async deleteUser(userId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM users WHERE id = ?',
        [userId],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }

  async updateUser(userId, updates) {
    const fields = [];
    const values = [];

    if (updates.username !== undefined) {
      fields.push('username = ?');
      values.push(updates.username);
    }
    if (updates.is_active !== undefined) {
      fields.push('is_active = ?');
      values.push(updates.is_active);
    }
    if (updates.theme_preference !== undefined) {
      fields.push('theme_preference = ?');
      values.push(updates.theme_preference);
    }

    if (fields.length === 0) {
      return false;
    }

    values.push(userId);

    return new Promise((resolve, reject) => {
      this.db.run(
        `UPDATE users SET ${fields.join(', ')} WHERE id = ?`,
        values,
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }

  // Download methods
  async addDownload(download) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT INTO downloads (id, user_id, playlist_id, title, artist, album, status, progress, created_at, torrent_data)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [download.id, download.userId || null, download.playlistId || null, download.title, download.artist, download.album, download.status, download.progress, download.created_at, download.torrent],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve({ id: this.lastID });
          }
        }
      );
    });
  }

  async getDownloads() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM downloads ORDER BY created_at DESC',
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async updateDownloadStatus(downloadId, status, progress = null) {
    return new Promise((resolve, reject) => {
      let query = 'UPDATE downloads SET status = ?';
      let params = [status];
      
      if (progress !== null) {
        query += ', progress = ?';
        params.push(progress);
      }
      
      query += ' WHERE id = ?';
      params.push(downloadId);
      
      this.db.run(query, params, function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes > 0);
        }
      });
    });
  }

  async deleteDownload(downloadId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM downloads WHERE id = ?',
        [downloadId],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }

  async updateDownloadRetry(downloadId, retryCount, errorLog = null) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'UPDATE downloads SET retry_count = ?, last_retry = CURRENT_TIMESTAMP, error_log = ? WHERE id = ?',
        [retryCount, errorLog, downloadId],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }

  async getDownloadsForRetry() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM downloads WHERE status = "downloading" AND retry_count < 10 ORDER BY created_at ASC',
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async getMusicByPath(filePath) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM music_library WHERE file_path = ?',
        [filePath],
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        }
      );
    });
  }

  async getMusicById(id) {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT * FROM music_library WHERE id = ?',
        [id],
        (err, row) => {
          if (err) {
            reject(err);
          } else {
            resolve(row);
          }
        }
      );
    });
  }

  async getMusicByTitleAndArtist(title, artist) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM music_library WHERE LOWER(title) = LOWER(?) AND LOWER(artist) = LOWER(?)',
        [title, artist],
        (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        }
      );
    });
  }

  async deleteMusicById(id) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM music_library WHERE id = ?',
        [id],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve(this.changes > 0);
          }
        }
      );
    });
  }

  // Remove duplicate songs (keep the one with the most complete metadata)
  async removeDuplicates() {
    return new Promise((resolve, reject) => {
      this.db.all(
        `SELECT title, artist, COUNT(*) as count, GROUP_CONCAT(id) as ids, GROUP_CONCAT(file_path) as paths
         FROM music_library 
         GROUP BY LOWER(title), LOWER(artist) 
         HAVING COUNT(*) > 1`,
        (err, duplicates) => {
          if (err) {
            reject(err);
          } else {
            let removedCount = 0;
            const removePromises = duplicates.map(duplicate => {
              const ids = duplicate.ids.split(',');
              const paths = duplicate.paths.split(',');
              
              // Keep the first one, remove the rest
              const idsToRemove = ids.slice(1);
              
              return new Promise((resolveRemove, rejectRemove) => {
                const deleteQuery = `DELETE FROM music_library WHERE id IN (${idsToRemove.map(() => '?').join(',')})`;
                this.db.run(deleteQuery, idsToRemove, function(err) {
                  if (err) {
                    rejectRemove(err);
                  } else {
                    removedCount += this.changes;
                    console.log(`ðŸ§¹ Removed ${this.changes} duplicates for: ${duplicate.title} - ${duplicate.artist}`);
                    resolveRemove();
                  }
                });
              });
            });
            
            Promise.all(removePromises).then(() => {
              console.log(`âœ… Removed ${removedCount} duplicate songs`);
              resolve(removedCount);
            }).catch(reject);
          }
        }
      );
    });
  }

  // Clean up songs with invalid file paths
  async cleanupInvalidPaths() {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM music_library',
        (err, songs) => {
          if (err) {
            reject(err);
          } else {
            // fs is already imported at the top
            let removedCount = 0;
            const removePromises = songs.map(song => {
              return new Promise((resolveRemove, rejectRemove) => {
                if (!fs.existsSync(song.file_path)) {
                  this.db.run(
                    'DELETE FROM music_library WHERE id = ?',
                    [song.id],
                    function(err) {
                      if (err) {
                        rejectRemove(err);
                      } else {
                        removedCount += this.changes;
                        console.log(`ðŸ§¹ Removed invalid path: ${song.file_path}`);
                        resolveRemove();
                      }
                    }
                  );
                } else {
                  resolveRemove();
                }
              });
            });
            
            Promise.all(removePromises).then(() => {
              console.log(`âœ… Removed ${removedCount} songs with invalid paths`);
              resolve(removedCount);
            }).catch(reject);
          }
        }
      );
    });
  }

  // Playlist methods
  async createPlaylist(userId, name, description = '') {
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO playlists (user_id, name, description) VALUES (?, ?, ?)',
        [userId, name, description],
        function(err) {
          if (err) {
            reject(err);
          } else {
            resolve({ id: this.lastID, name, description });
          }
        }
      );
    });
  }

  async getPlaylists(userId = null) {
    return new Promise((resolve, reject) => {
      // First, get playlists with track counts
      let query = `
        SELECT p.*, 
               COUNT(pt.id) as track_count
        FROM playlists p
        LEFT JOIN playlist_tracks pt ON p.id = pt.playlist_id
      `;
      let params = [];
      
      if (userId) {
        query += ' WHERE p.user_id = ?';
        params.push(userId);
      }
      
      query += ' GROUP BY p.id ORDER BY p.created_at DESC';
      
      this.db.all(query, params, async (err, playlists) => {
        if (err) {
          reject(err);
          return;
        }
        
        // Then fetch artwork for each playlist (optimized single query per playlist)
        const playlistsWithArtwork = await Promise.all(
          playlists.map(async (playlist) => {
            return new Promise((resolveArt) => {
              this.db.get(
                `SELECT m.album_cover 
                 FROM playlist_tracks pt 
                 JOIN music_library m ON pt.music_id = m.id 
                 WHERE pt.playlist_id = ? AND m.album_cover IS NOT NULL
                 ORDER BY pt.position ASC, pt.added_at ASC 
                 LIMIT 1`,
                [playlist.id],
                (err, row) => {
                  if (err || !row) {
                    resolveArt({ ...playlist, artwork: null });
                  } else {
                    resolveArt({ ...playlist, artwork: row.album_cover });
                  }
                }
              );
            });
          })
        );
        
        resolve(playlistsWithArtwork);
      });
    });
  }

  async getPlaylistById(playlistId, userId = null) {
    return new Promise((resolve, reject) => {
      let query = `
        SELECT p.*, 
               COUNT(pt.id) as track_count,
               GROUP_CONCAT(m.title) as track_titles,
               GROUP_CONCAT(m.artist) as track_artists
        FROM playlists p
        LEFT JOIN playlist_tracks pt ON p.id = pt.playlist_id
        LEFT JOIN music_library m ON pt.music_id = m.id
        WHERE p.id = ?
      `;
      let params = [playlistId];
      
      if (userId) {
        query += ' AND p.user_id = ?';
        params.push(userId);
      }
      
      query += ' GROUP BY p.id';
      
      this.db.get(query, params, (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row);
        }
      });
    });
  }

  async getPlaylistTracks(playlistId, userId = null) {
    return new Promise((resolve, reject) => {
      let query = `
        SELECT m.*, pt.position, pt.added_at as added_to_playlist
        FROM playlist_tracks pt
        JOIN music_library m ON pt.music_id = m.id
        JOIN playlists p ON pt.playlist_id = p.id
        WHERE pt.playlist_id = ?
      `;
      let params = [playlistId];
      
      if (userId) {
        query += ' AND p.user_id = ?';
        params.push(userId);
      }
      
      query += ' ORDER BY pt.position ASC, pt.added_at ASC';
      
      this.db.all(query, params, (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  async addTrackToPlaylist(playlistId, musicId, position = null, userId = null) {
    return new Promise((resolve, reject) => {
      // First verify the playlist belongs to the user
      if (userId) {
        this.db.get(
          'SELECT id FROM playlists WHERE id = ? AND user_id = ?',
          [playlistId, userId],
          (err, playlist) => {
            if (err) {
              reject(err);
            } else if (!playlist) {
              reject(new Error('Playlist not found or access denied'));
            } else {
              this._addTrackToPlaylistInternal(playlistId, musicId, position, resolve, reject);
            }
          }
        );
      } else {
        this._addTrackToPlaylistInternal(playlistId, musicId, position, resolve, reject);
      }
    });
  }

  _addTrackToPlaylistInternal(playlistId, musicId, position, resolve, reject) {
    // Check if track is already in playlist
    this.db.get(
      'SELECT id FROM playlist_tracks WHERE playlist_id = ? AND music_id = ?',
      [playlistId, musicId],
      (err, existing) => {
        if (err) {
          reject(err);
        } else if (existing) {
          reject(new Error('Track already in playlist'));
        } else {
          // Get next position if not specified
          if (position === null) {
            this.db.get(
              'SELECT MAX(position) as max_pos FROM playlist_tracks WHERE playlist_id = ?',
              [playlistId],
              (err, result) => {
                if (err) {
                  reject(err);
                } else {
                  const nextPosition = (result.max_pos || 0) + 1;
                  this._insertPlaylistTrack(playlistId, musicId, nextPosition, resolve, reject);
                }
              }
            );
          } else {
            this._insertPlaylistTrack(playlistId, musicId, position, resolve, reject);
          }
        }
      }
    );
  }

  _insertPlaylistTrack(playlistId, musicId, position, resolve, reject) {
    this.db.run(
      'INSERT INTO playlist_tracks (playlist_id, music_id, position) VALUES (?, ?, ?)',
      [playlistId, musicId, position],
      function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ id: this.lastID });
        }
      }
    );
  }

  async removeTrackFromPlaylist(playlistId, musicId, userId = null) {
    return new Promise((resolve, reject) => {
      let query = `
        DELETE FROM playlist_tracks 
        WHERE playlist_id = ? AND music_id = ?
      `;
      let params = [playlistId, musicId];
      
      // If userId provided, verify playlist ownership
      if (userId) {
        query = `
          DELETE FROM playlist_tracks 
          WHERE playlist_id = ? AND music_id = ? 
          AND EXISTS (SELECT 1 FROM playlists WHERE id = ? AND user_id = ?)
        `;
        params = [playlistId, musicId, playlistId, userId];
      }
      
      this.db.run(query, params, function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes > 0);
        }
      });
    });
  }

  async updatePlaylist(playlistId, updates, userId = null) {
    return new Promise((resolve, reject) => {
      const fields = [];
      const values = [];

      if (updates.name !== undefined) {
        fields.push('name = ?');
        values.push(updates.name);
      }
      if (updates.description !== undefined) {
        fields.push('description = ?');
        values.push(updates.description);
      }

      if (fields.length === 0) {
        resolve(false);
        return;
      }

      let query = `UPDATE playlists SET ${fields.join(', ')} WHERE id = ?`;
      let params = [...values, playlistId];
      
      if (userId) {
        query += ' AND user_id = ?';
        params.push(userId);
      }

      this.db.run(query, params, function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes > 0);
        }
      });
    });
  }

  async deletePlaylist(playlistId, userId = null) {
    return new Promise((resolve, reject) => {
      let query = 'DELETE FROM playlists WHERE id = ?';
      let params = [playlistId];
      
      if (userId) {
        query += ' AND user_id = ?';
        params.push(userId);
      }

      this.db.run(query, params, function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes > 0);
        }
      });
    });
  }

  async reorderPlaylistTracks(playlistId, trackOrders, userId = null) {
    return new Promise((resolve, reject) => {
      // Verify playlist ownership if userId provided
      if (userId) {
        this.db.get(
          'SELECT id FROM playlists WHERE id = ? AND user_id = ?',
          [playlistId, userId],
          (err, playlist) => {
            if (err) {
              reject(err);
            } else if (!playlist) {
              reject(new Error('Playlist not found or access denied'));
            } else {
              this._reorderPlaylistTracksInternal(playlistId, trackOrders, resolve, reject);
            }
          }
        );
      } else {
        this._reorderPlaylistTracksInternal(playlistId, trackOrders, resolve, reject);
      }
    });
  }

  _reorderPlaylistTracksInternal(playlistId, trackOrders, resolve, reject) {
    // Begin transaction
    this.db.serialize(() => {
      this.db.run('BEGIN TRANSACTION');
      
      let completed = 0;
      const total = trackOrders.length;
      
      if (total === 0) {
        this.db.run('COMMIT', (err) => {
          if (err) reject(err);
          else resolve(true);
        });
        return;
      }
      
      trackOrders.forEach(({ musicId, position }) => {
        this.db.run(
          'UPDATE playlist_tracks SET position = ? WHERE playlist_id = ? AND music_id = ?',
          [position, playlistId, musicId],
          (err) => {
            if (err) {
              this.db.run('ROLLBACK');
              reject(err);
            } else {
              completed++;
              if (completed === total) {
                this.db.run('COMMIT', (err) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(true);
                  }
                });
              }
            }
          }
        );
      });
    });
  }

  // Get albums grouped with track count (optimized SQL query)
  async getAlbumsGrouped(userId = null) {
    return new Promise(async (resolve, reject) => {
      try {
        let query, params;
        const isAdmin = userId ? await this.isUserAdmin(userId) : false;
        
        if (userId && !isAdmin) {
          // Regular user: Show only their music (user_id matches OR user_id is NULL for global music)
          query = `
            SELECT 
              album,
              artist,
              COUNT(*) as trackCount,
              MAX(album_cover) as albumCover
            FROM music_library
            WHERE (user_id = ? OR user_id IS NULL) AND album IS NOT NULL
            GROUP BY LOWER(album), LOWER(artist)
            ORDER BY album ASC
          `;
          params = [userId];
        } else {
          // Admin or no userId: Show ALL music
          query = `
            SELECT 
              album,
              artist,
              COUNT(*) as trackCount,
              MAX(album_cover) as albumCover
            FROM music_library
            WHERE album IS NOT NULL
            GROUP BY LOWER(album), LOWER(artist)
            ORDER BY album ASC
          `;
          params = [];
        }
        
        this.db.all(query, params, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  // Get artists grouped with track counts (optimized SQL)
  async getArtistsGrouped(userId = null) {
    return new Promise(async (resolve, reject) => {
      try {
        let query, params;
        const isAdmin = userId ? await this.isUserAdmin(userId) : false;
        
        if (userId && !isAdmin) {
          // Regular user: Show only their music (user_id matches OR user_id IS NULL for global music)
          query = `
            SELECT 
              CASE 
                WHEN file_path LIKE '%/music/%' THEN 
                  SUBSTR(file_path, INSTR(file_path, '/music/') + 7, 
                    INSTR(SUBSTR(file_path, INSTR(file_path, '/music/') + 7), '/') - 1)
                WHEN file_path LIKE 'music/%' THEN 
                  SUBSTR(file_path, 7, INSTR(SUBSTR(file_path, 7), '/') - 1)
                ELSE 'Unknown Artist'
              END as name,
              COUNT(*) as trackCount,
              MAX(artist_image) as artistImage
            FROM music_library
            WHERE (user_id = ? OR user_id IS NULL)
            GROUP BY LOWER(name)
            ORDER BY name ASC
          `;
          params = [userId];
        } else {
          // Admin or no userId: Show ALL music
          query = `
            SELECT 
              CASE 
                WHEN file_path LIKE '%/music/%' THEN 
                  SUBSTR(file_path, INSTR(file_path, '/music/') + 7, 
                    INSTR(SUBSTR(file_path, INSTR(file_path, '/music/') + 7), '/') - 1)
                WHEN file_path LIKE 'music/%' THEN 
                  SUBSTR(file_path, 7, INSTR(SUBSTR(file_path, 7), '/') - 1)
                ELSE 'Unknown Artist'
              END as name,
              COUNT(*) as trackCount,
              MAX(artist_image) as artistImage
            FROM music_library
            GROUP BY LOWER(name)
            ORDER BY name ASC
          `;
          params = [];
        }
        
        this.db.all(query, params, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  // Get all music files from database
  async getAllMusicFiles() {
    return new Promise((resolve, reject) => {
      this.db.all('SELECT * FROM music_library', (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }

  // Update an existing music file
  async updateMusicFile(id, filePath, musicData) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `UPDATE music_library SET 
         file_path = ?, title = ?, artist = ?, album = ?, year = ?, 
         genre = ?, duration = ?, file_size = ?, bitrate = ?, added_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          filePath, musicData.title, musicData.artist, musicData.album, 
          musicData.year, musicData.genre, musicData.duration, 
          musicData.fileSize, musicData.bitrate, id
        ],
        function(err) {
          if (err) reject(err);
          else resolve({ success: true, changes: this.changes });
        }
      );
    });
  }

  // Update just the file path (for folder renames)
  async updateMusicFilePath(id, newFilePath) {
    return new Promise((resolve, reject) => {
      this.db.run(
        `UPDATE music_library SET file_path = ?, added_at = CURRENT_TIMESTAMP WHERE id = ?`,
        [newFilePath, id],
        function(err) {
          if (err) reject(err);
          else resolve({ success: true, changes: this.changes });
        }
      );
    });
  }
}

export default Database;
